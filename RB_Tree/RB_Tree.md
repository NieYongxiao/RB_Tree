红黑树是一种特殊的二叉搜索树，除二叉搜索树的性质以外，还具有以下五个性质：
1.每个结点不是红色就是黑色。
2.根结点是黑色的。
3.如果一个结点是红色的，则它的两个孩子结点是黑色的。
4.对于每个结点，从该结点到其所有后代叶子结点的简单路径上，均包含相同数目的黑色结点。
5.每个叶子结点都是黑色的（此处的叶子结点指定是空结点）。
由性质3可以得出，红黑树当中不会出现连续的红色结点，由性质3 4可以得出，红黑树从根到叶子的最长可能路径不会超过最短可能路径的两倍

当我们向红黑树插入结点时，若插入的是黑色结点，那么插入路径上黑色结点的数目就比其他路径上黑色结点的数目多了一个，
即破坏了红黑树的性质4，此时我们就需要对红黑树进行调整。
若我们插入红黑树的结点是红色的，此时如果其父结点也是红色的，那么表明出现了连续的红色结点，即破坏了红黑树的性质3，
此时我们需要对红黑树进行调整；但如果其父结点是黑色的，那我们就无需对红黑树进行调整，插入后仍满足红黑树的要求。
总结一下：
插入黑色结点，一定破坏红黑树的性质4，必须对红黑树进行调整。
插入红色结点，可能破坏红黑树的性质3，可能对红黑树进行调整。
权衡利弊后，我们在构造结点进行插入时，默认将结点的颜色设置为红色。

验证一棵树是否是红黑树，要检测其是否满足红黑树的性质。
1.空树也是红黑树；
2.根节点必须是黑色的；
3.不能有连续的红色节点，如果当前节点为红色，那么我们去检查他的父亲是否为红色，如果是则证明这棵树不是红黑树，这里为什么不去检查节点的孩子呢？因为节点的孩子是不确定的，我们不知道他是否有左孩子或或者右孩子，但是他一定有父亲节点。
4.每条路径上的黑色节点相同，先记录一条路径的黑色节点的个数作为基准值，再统计每条路径的黑色节点的个数进行判断，看是否符合要求。

查找很简单，插入和删除是难点

红黑树与AVL树的比较
红黑树和AVL树都是高效的平衡二叉树，增删查改的时间复杂度都是O(logN)，
但红黑树和AVL树控制二叉树平衡的方式不同：
AVL树是通过控制左右高度差不超过1来实现二叉树平衡的，实现的是二叉树的严格平衡。
红黑树是通过控制结点的颜色，从而使得红黑树当中最长可能路径不超过最短可能路径的2倍，实现的是近似平衡。
相对于AVL树来说，红黑树降低了插入结点时需要进行的旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，实际运用时也大多用的是红黑树。

详情请看https://blog.csdn.net/chenlong_cxy/article/details/121481859




在这里使用了模板函数分离编译的写法，容易出现很多问题，比如:
1.语法错误不报错，只说编译失败，不知道具体错在哪里
2.实际调用时会找不到函数定义，因为模板类不是一个具体的类型，没有相关的代码，只有在对模板类进行实例化后，才会生成一个具体的类和类内部的成员函数。所以如果没有实例化，是不可能使用模板类中的成员函数的。
详情请看https://blog.csdn.net/Johnsonjjj/article/details/106902533
因此，实际编程过程中最好将模板类的成员函数声明和定义都放在头文件中